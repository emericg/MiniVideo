/*!
 * COPYRIGHT (C) 2020 Emeric Grange - All Rights Reserved
 *
 * This file is part of MiniVideo.
 *
 * MiniVideo is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MiniVideo is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with MiniVideo.  If not, see <http://www.gnu.org/licenses/>.
 *
 * \file      h265_nalu.h
 * \author    Emeric Grange <emeric.grange@gmail.com>
 * \date      2024
 */

#ifndef H265_NALU_H
#define H265_NALU_H
/* ************************************************************************** */

// minivideo headers
#include "../../bitstream.h"

/* ************************************************************************** */

/*!
 * \brief H.265 NAL Unit - Network Abstraction Layer Unit.
 *
 * From 'ITU-T H.265' recommendation:
 * - 7.3.1 NAL unit syntax.
 * - 7.4.2 NAL unit semantics.
 *
 * A NAL (Network Abstraction Layer) is specified to format that data and provide
 * header information in a manner appropriate for conveyance on a variety of
 * communication channels or storage media.
 *
 * All coded video data are organized into NAL units, each of which is effectively
 * a packet that contains an integer number of bytes. The first byte of each NAL
 * unit is a header byte that contains an indication of the type of data in the
 * NAL unit, and the remaining bytes contain payload data of the type indicated
 * by the header.
 *
 * The NAL unit structure definition specifies a generic format for use in both
 * packet-oriented and bitstream-oriented transport systems, and a series of NAL
 * units generated by an encoder is referred to as a NAL unit stream.
 */
typedef struct h265_nalu_t
{
    // Nal Unit offset
    int64_t nal_offset;             //!< Absolute offset of the NAL Unit header (in byte)

    // Nal Unit header
    uint8_t nal_unit_type;          //!< Define NAL Unit content type (see h265_nalu_type_e enum)
    uint8_t nuh_layer_id;           //!<
    uint8_t nuh_temporal_id_plus1;  //!<

} h265_nalu_t;

//! H.265 NAL Unit content type
typedef enum h265_nalu_type_e
{
    NALU_TYPE_TRAIL_N       = 0,    //!< Coded slice segment of a non-TSA, non-STSA trailing picture
    NALU_TYPE_TRAIL_R       = 1,
    NALU_TYPE_TSA_N         = 2,    //!< Coded slice segment of a TSA picture
    NALU_TYPE_TSA_R         = 3,
    NALU_TYPE_STSA_N        = 4,    //!< Coded slice segment of an STSA picture
    NALU_TYPE_STSA_R        = 5,
    NALU_TYPE_RADL_N        = 6,    //!< Coded slice segment of a RADL picture
    NALU_TYPE_RADL_R        = 7,
    NALU_TYPE_RASL_N        = 8,    //!< Coded slice segment of a RASL picture
    NALU_TYPE_RASL_R        = 9,

    NALU_TYPE_RSV_VCL_N10   = 10,   //!< Reserved non-IRAP SLNR VCL NAL unit types
    NALU_TYPE_RSV_VCL_N12   = 12,
    NALU_TYPE_RSV_VCL_N14   = 14,
    NALU_TYPE_RSV_VCL_R11   = 11,   //!< Reserved non-IRAP sub-layer reference VCL NAL unit types
    NALU_TYPE_RSV_VCL_R13   = 13,
    NALU_TYPE_RSV_VCL_R15   = 15,

    NALU_TYPE_BLA_W_LP      = 16,   //!< Coded slice segment of a BLA picture
    NALU_TYPE_BLA_W_RADL    = 17,
    NALU_TYPE_BLA_N_LP      = 18,
    NALU_TYPE_IDR_W_RADL    = 19,   //!< Coded slice segment of an IDR picture
    NALU_TYPE_IDR_N_LP      = 20,
    NALU_TYPE_CRA_NUT       = 21,   //!< Coded slice segment of a CRA picture

    NALU_TYPE_RSV_IRAP_VCL22= 22,   //!< Reserved IRAP VCL NAL unit types
    NALU_TYPE_RSV_IRAP_VCL23= 23,

    NALU_TYPE_VPS_NUT       = 32,   //!< Video Parameter Set
    NALU_TYPE_SPS_NUT       = 33,   //!< Sequence Parameter Set
    NALU_TYPE_PPS_NUT       = 34,   //!< Picture Parameter Set
    NALU_TYPE_AUD_NUT       = 35,   //!< Access Unit Delimiter
    NALU_TYPE_EOS_NUT       = 36,   //!< End of Sequence
    NALU_TYPE_EOB_NUT       = 37,   //!< End of Bitstream
    NALU_TYPE_FD_NUT        = 38,   //!< Filler Data
    NALU_TYPE_PREFIX_SEI_NUT= 39,   //!< Supplemental Enhancement Information
    NALU_TYPE_SUFFIX_SEI_NUT= 40,   //!< Supplemental Enhancement Information

} h265_nalu_type_e;

/* ************************************************************************** */

h265_nalu_t *h265_nalu_init(void);

void h265_nalu_reset(h265_nalu_t *nalu);
int h265_nalu_get_next_startcode(Bitstream_t *bitstr, h265_nalu_t *nalu);
int h265_nalu_parse_header(Bitstream_t *bitstr, h265_nalu_t *nalu);

int h265_nalu_clean_sample(Bitstream_t *bitstr);

const char *h265_nalu_get_string_type0(h265_nalu_t *nalu);
const char *h265_nalu_get_string_type1(unsigned type);

/* ************************************************************************** */
#endif // H265_NALU_H
